Run Generated Quantities
========================

The `generated quantities block <https://mc-stan.org/docs/reference-manual/program-block-generated-quantities.html>`__
computes *quantities of interest* (QOIs) based on the data,
transformed data, parameters, and transformed parameters.
It can be used to:

-  generate simulated data for model testing by forward sampling
-  generate predictions for new data
-  calculate posterior event probabilities, including multiple
   comparisons, sign tests, etc.
-  calculating posterior expectations
-  transform parameters for reporting
-  apply full Bayesian decision theory
-  calculate log likelihoods, deviances, etc. for model comparison

The :ref:`class_cmdstanmodel` class ``generate_quantities`` method is useful once you
have successfully fit a model to your data and have a valid
sample from the posterior and a version of the original model
where the generated quantities block contains the necessary statements
to compute additional quantities of interest.

By running the ``generate_quantities`` method on the new model with
a sample generated by the existing model, the sampler uses the
per-draw parameter estimates from the sample to compute the
generated quantities block of the new model.


The ``generate_quantities`` method returns a ``CmdStanGQ`` object
which provides properties to retrieve information about the metatdata
and sample:

- ``chains``: Number of sampler chains. 
- ``chain_ids``: The offset or list of per-chain offsets for the random number generator. 

- ``draws`` - The numpy.ndarray which contains all across all chains. By default, returns a 3D array (draws, chains, columns); the argument ``concat_chains`` returns a 2D array which flattens the chains into a single set of draws.
- ``stan_variable(name=var_name)`` - Returns a numpy.ndarray which contains the set of draws in the sample for the named Stan program variable.
- ``stan_variables()`` - Returns a Python dict, key: Stan program variable name, value: numpy.ndarray of draws.



The ``sample_plus_quantities`` combines the existing sample
and new quantities of interest into a pandas DataFrame object
which can be used for downstream analysis and visualization.
In this way you add more columns of information to an existing sample.


Configuration
-------------

- ``mcmc_sample`` - either a ``CmdStanMCMC`` object or a list of stan-csv files

- ``data``: Values for all data variables in the model, specified either as a dictionary with entries matching the data variables, or as the path of a data file in JSON or Rdump format.

- ``seed``: The seed for random number generator.
            
- ``gq_output_dir``:  A path or file name which will be used as the basename for the CmdStan output files.


Example: add posterior predictive checks to ``bernoulli.stan``
--------------------------------------------------------------

In this example we use the CmdStan example model
`bernoulli.stan <https://github.com/stan-dev/cmdstanpy/blob/master/test/data/bernoulli.stan>`__
and data file
`bernoulli.data.json <https://github.com/stan-dev/cmdstanpy/blob/master/test/data/bernoulli.data.json>`__
as our existing model and data.
We create the program
`bernoulli_ppc.stan <https://github.com/stan-dev/cmdstanpy/blob/master/test/data/bernoulli_ppc.stan>`__
by adding a ``generated quantities`` block to bernoulli.stan
which generates a new data vector ``y_rep`` using the current estimate of theta.

.. code::

    generated quantities {
      int y_sim[N];
      real<lower=0,upper=1> theta_rep;
      for (n in 1:N)
        y_sim[n] = bernoulli_rng(theta);
      theta_rep = sum(y) / N;
    }


The first step is to fit model ``bernoulli`` to the data:

.. code:: python

    import os
    from cmdstanpy import CmdStanModel, cmdstan_path

    bernoulli_dir = os.path.join(cmdstan_path(), 'examples', 'bernoulli')
    bernoulli_path = os.path.join(bernoulli_dir, 'bernoulli.stan')
    bernoulli_data = os.path.join(bernoulli_dir, 'bernoulli.data.json')

    # instantiate, compile bernoulli model
    bernoulli_model = CmdStanModel(stan_file=bernoulli_path)

    # fit the model to the data
    bern_fit = bernoulli_model.sample(data=bernoulli_data)


Then we compile the model ``bernoulli_ppc`` and use the fit parameter estimates
to generate quantities of interest:


.. code:: python

    bernoulli_ppc_model = CmdStanModel(stan_file='bernoulli_ppc.stan')
    new_quantities = bernoulli_ppc_model.generate_quantities(data=bern_data, mcmc_sample=bern_fit)

The ``generate_quantities`` method returns a ``CmdStanGQ`` object which
contains the values for all variables in the generated quantitites block
of the program ``bernoulli_ppc.stan``. Unlike the output from the
``sample`` method, it doesnâ€™t contain any information on the joint log
probability density, sampler state, or parameters or transformed
parameter values.

.. code:: python

    new_quantities.column_names
    new_quantities.generated_quantities.shape
    for i in range(len(new_quantities.column_names)):
        print(new_quantities.generated_quantities[:,i].mean())


The method ``sample_plus_quantities`` returns a pandas DataFrame which
combines the input drawset with the generated quantities.

.. code:: python

    sample_plus = new_quantities.sample_plus_quantities
    print(sample_plus.shape)
    print(sample_plus.columns)        
